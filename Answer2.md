# Puzzle 2: The Software Design Principles

## Encapsulation→ You use me to keep the parts of your code that stay the same separate from the parts that change, then it’s really easy to make changes to your code without breaking everything

## Flexibility→ Use me so that your software can change and grow without constant rework. I keep your application from being fragile

## Functionality→ Without me, you'll never actually make the customer happy. No matter how well-designed your application is, I'm the thing that puts a smile on the customer's face

## Design Pattern→ I’m all about reuse and making sure you’re not trying to solve a problem that someone else has already figured out

## External Initiator→ Kicks off the list of steps described in a use case. Without this, a use case never gets going

## Use Case→ Helps you gather good requirements. Tells a story about how a system works

## Start Condition→ This is always the first step in the use case

## Requirement→ Something a system has to do to be a success

## Clear Value→ Without this, a use case isn’t worth anything to anyone. Use cases without this always fail

## Stop Condition→ Lets you know when a use case is finished. Without this, use cases can go on forever

## Main Path→ How a system works when everything is going right. This is usually what customers describe when they’re talking about the system

## Noun Analysis→ You do this to your use case to figure out what classes you need in your system

## Multiplicity→ Describes how many of a specific type can be stored in an attribute of a class

## Attribute→ Equivalent to a member variable in a class

## Class Diagram→ Lists all the code-level constructs, along with their attributes and operations

## Operation→ This is the UML term that usually represents a method in one of your classes

## Association→ Visually shows that one class has a relation to another class, usually through an attribute

## Verb Analysis→ Helps you figure out the candidates for methods or the objects in your system
